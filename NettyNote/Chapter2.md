# Netty编解码相关



## 06|粘包/拆包问题：如何获取一个完整的网络包？

### 拆包/粘包

TCP传输协议是面向流的，没有数据包的界限。所以每次传输的网络包大小不同，也就导致了发送出去的数据可能不是一个完整的数据包，也就是拆包，或者将多个数据包合成一个网络包然后发送出去，也就是所谓的粘包。

### 拆包/粘包的基本情况

[![Whm154.png](https://z3.ax1x.com/2021/07/26/Whm154.png)](https://imgtu.com/i/Whm154)

1. A和B两个数据包都通过单独的网络包发送出去，服务端分别单独解析即可
2. A和B通过一个网络包发送出去，服务端需要对其进行拆分
3. A和B的一部分是一个网络包，B的另一部分通过一个网络包发送出去，服务端要拆分出B的前半部分缓存起来，等待
   B的后一部分
4. A的一部分通过网络包发送出去，A的另一部分和B通过一个网络包发送出去，要先缓存A的一部分，等到第二个网络包到解析出来组成完整的A
5. A分成了多个网络包发送出去，缓存A的每部分并拼接

### 解决办法：自定义应用层通信协议

常见的几种协议方式为

#### 定长消息

所有消息长度都一定，如果不足用空位补齐。

- 缺点
  1. 当消息长度不确定时会浪费网络资源，必须保证消息长度满足你所发消息的最大值

#### 特定分隔符

使用特殊的字符对消息进行拆分，在发送消息的尾部添加特殊字符串。

- 缺点
  1. 如果消息中会出现特殊字符，需要考虑冲突处理

比较推荐的做法是将消息进行编码，例如 base64 编码，然后可以选择 64 个编码字符之外的字符作为特定分隔符。



#### 消息长度+消息内容

```
消息头     消息体

+--------+----------+

| Length |  Content |

+--------+----------+

```

最常见的协议，消息头描述消息的总长度，接收方先解析消息头获取到总长度，然后读取总长度的字符。

消息长度 + 消息内容的使用方式非常灵活，且不会存在消息定长法和特定分隔符法的明显缺陷。当然在消息头中不仅只限于存放消息的长度，而且可以自定义其他必要的扩展字段，例如消息版本、算法类型等。



## 07|接头暗语：如何利用Netty实现自定义协议通信

### 通信协议设计

通信协议要素

1. 魔数：通信双方商定的暗号，防止任何人随便向服务器的端口上发送数据
2. 协议版本号：对不同版本的协议解析是不同的
3. 序列化算法
4. 报文类型
5. 长度域字段
6. 请求数据
7. 状态
8. 保留字段